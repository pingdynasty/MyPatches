#ifndef __StereoChorusPatch_h__
#define __StereoChorusPatch_h__

#include "OpenWareLibrary.h"
#include "MorphingLFO.h"

// Flangers use much shorter delay times (1ms to 5ms) compared to choruses (5ms to 30ms) and only involve one copy of the original signal while choruses can create multiple copies.

// Figure 10: A four-path chorus unit.
// LFO1 ->
// LFO2 -> Mixer -> tap 1 |
// LFO3 ->
// LFO4 -> Mixer -> tap 2 |
// LFO5 ->
// LFO6 -> Mixer -> tap 3 |
// Dry                    +> Output
// Now consider Figure 10. This shows the input split into four paths — the original signal plus three delayed versions of it. Each of the six LFOs in the patch can have a different modulation rate, and each of the mixers in the modulation paths can be designed so that each of the LFOs contributes a different depth. The result is a lush, complex swirl of sound that is forever evolving, and which adds movement and texture to even the most basic of initial waveforms.
  
// Figure 11: Reconfiguring the LFOs to produce a modulation signal with vibrato.
// LFO1 -> LFO2 -> tap 1

// Another variation on this approach rearranges the LFOs so that one of each pair modulates the frequency of the other. This arrangement, which I've shown in Figure 11 produces the waveform in Figure 12, creating yet another form of pitch modulation and, therefore, a subtly different chorus

// Figure 13: The classic three-phase chorus unit.
// 0 deg   120 deg          240 deg
// LFO1 |> phase shift 1 |> phase shift 3 |
// LFO2 |> phase shift 2 |> phase shift 4 |
//      +> tap 1 |       +> tap 2 |       +> tap 3 |
// Dry           +>               +>               +> Output
// A slow sweep at a fraction of 1Hz will provide a gentle chorus, while a faster rate — say, 5Hz to 7Hz — will result in a more typical 'synth' ensemble.

// As you might imagine, circuits such as Figure 10 can be expensive to build, and although this design produces a superb ensemble sound, it may not be economical. To overcome this, many manufacturers combined the ideas set out in Figures 7 and 10, employing a trick that fools the ear into believing that it's hearing multiple, complex modulations, when in fact only one is present (see Figure 13, below).

// This involves the use of just two LFOs (which cuts costs) and four phase-shifters (which are cheap), and generates three instances of a single complex delay modulation. As before, these are out of phase with one another, typically by 120 degrees, and the result, while not quite as lush as you can obtain using six independent LFOs, is nonetheless gorgeous. This is why this method — or close variations of it — became the standard for almost all the best-loved chorus/ensemble keyboards.

// Eminent Solina (1974) uses the chorus structure depicted in Figure 11, with two LFOs, one running at around 1Hz and the other at about 6Hz, phase-shifted to produce modulating signals at 0 degrees, 120 degrees and 240 degrees. In contrast, the Roland VP330 (1978) has a thinner string ensemble sound generated by just two delay lines with dual LFOs. The altogether richer-sounding Korg Polysix synthesizer (1981) incorporates another triple-delay chorus, but dispenses with the phase-shifters and uses a configuration of independent LFOs similar to that shown in Figure 10 (above).

// The other vital factor is the delay time. Set this to be too long, and you'll hear a distinct delay. Set it too short, and you'll obtain a version of another effect: flanging. But get it right — somewhere in the range 10ms to 50ms, as your taste dictates — and then mix the two signal paths in equal measure, and you'll obtain a serviceable chorus

// Synthesizer designers continued to dream up better ways to modulate the input signal, the first of which was to modulate each delay line with not one LFO, but two. Many manufacturers opted for two very different speeds — one of the order 0.5Hz to 0.7Hz, with a second closer to 6Hz to 7Hz, but with no discerned integer relationship between the two, so that the modulation didn't repeat for a long time.

#define TRIGGER_LIMIT (1<<22)
constexpr size_t taps = 3;

template<size_t TAPS=3>
class ChorusProcessor : public SignalProcessor {
protected:
  typedef CrossFadingCircularBuffer<float> CircularBufferType;
  // typedef InterpolatingCircularFloatBuffer<HERMITE_INTERPOLATION> CircularBufferType;
  CircularBufferType* ringbuffer[TAPS];
  FloatArray inbuf;
  FloatArray outbuf;
  BiquadFilter* lpf;
  BiquadFilter* hpf;
  float depth;
  float delay;
  float spread;
  float amount;
  float phase;
public:
  ChorusProcessor(float sr, size_t bs, size_t ds){
    lpf = BiquadFilter::create(sr, 1);
    lpf->setLowPass(6000, FilterStage::BUTTERWORTH_Q);
    hpf = BiquadFilter::create(sr, 1);
    hpf->setHighPass(200, FilterStage::BUTTERWORTH_Q);
    for(size_t i=0; i<TAPS; ++i){
      // ringbuffer[i] = CircularBufferType::create(ds);
      ringbuffer[i] = CircularBufferType::create(ds, bs);
    }
    inbuf = FloatArray::create(bs);
    outbuf = FloatArray::create(bs);
  }
  ~ChorusProcessor(){
    FloatArray::destroy(inbuf);
    FloatArray::destroy(outbuf);
    for(size_t i=0; i<TAPS; ++i)
      CircularBufferType::destroy(ringbuffer[i]);
    BiquadFilter::destroy(lpf);
    BiquadFilter::destroy(hpf);
  }
  /**
   * @param value should be from 0 to 1
   */
  void setDelay(float value){
    delay = ringbuffer[0]->getSize()*0.25f + value*(ringbuffer[0]->getSize())*0.25f;
  }
  void setDepth(float value){
    depth = value*delay*0.5f;
    // depth = value*ringbuffer[0]->getSize()/4.0f; // max depth 1/4 buffer
  }
  void setSpread(float value){
    spread = value*delay/(2*(TAPS-1));
    // spread = value*ringbuffer[0]->getSize()/(4*(TAPS-1)); // max spread 1/4 buffer per tap
  }
  void setAmount(float value){
    amount = value;
  }
  void setFeedback(float value){
    feedback = value;
  }
  /*
   * Phase should be between -1 and 1
   */
  void setPhase(float value){
    phase = value;
  }
  void setLowPass(float fc){
    lpf->setLowPass(fc*4000 + 4000, FilterStage::BUTTERWORTH_Q);
  }
  void setHighPass(float fc){
    lpf->setHighPass(fc*400 + 40, FilterStage::BUTTERWORTH_Q);
  }
  // float process(float input){
  //   for(size_t i=0; i<TAPS; ++i){
  //     ringbuffer[i].write(input);
  //   }
  // }
  void process(FloatArray input, FloatArray output){
    ASSERT(input.getData() != output.getData(), "Inplace processing not supported");
    output.clear();
    lpf->process(input, inbuf);
    hpf->process(inbuf, inbuf);
    float ph = phase;
    for(size_t i=0; i<TAPS; ++i){
      float dt = delay + depth*ph + spread*i;
      ringbuffer[i]->delay(inbuf, outbuf, inbuf.getSize(), dt);
      output.add(outbuf);
      ph *= -1; // move taps in alternating directions
    }
    output.multiply(amount/(TAPS*0.707));
    outbuf.copyFrom(input);
    outbuf.multiply(1-amount);
    output.add(outbuf);
  }
};

#if 0
template<size_t TAPS=3>
class StereoChorusProcessor : public MultiSignalProcessor {
  // typedef InterpolatingCircularFloatBuffer<HERMITE_INTERPOLATION> CircularBufferType;
  typedef CrossFadingCircularBuffer<float> CircularBufferType;
protected:
  AudioBuffer* buffer;
  CircularBufferType* ringbufferL;
  CircularBufferType* ringbufferR;
  MultiBiquadFilter* filter;
  float depth;
  SmoothFloat delay;
  SmoothFloat spread;
  SmoothFloat amount;
  size_t delay_times[TAPS*2];
public:
  StereoChorusProcessor(AudioBuffer* buffer, CircularBufferType* ringbufferL,
			CircularBufferType* ringbufferR, MultiBiquadFilter* filter) :			
    buffer(buffer), ringbufferL(ringbufferL), ringbufferR(ringbufferR), filter(filter),
    depth(0), delay(0), spread(0), amount(0) {
    if(ringbufferL)
      delay = 0.5*ringbufferL->getSize();
    for(size_t i=0; i<TAPS*2; ++i)
      delay_times[i] = delay;
  }
  /**
   * @param value should be from 0 to 1
   */
  void setDelay(float value){
    delay = value*ringbufferL->getSize() - buffer->getSize();
    // subtract one buffer length because we write before we read
  }
  void setDepth(float value){
    depth = value;
  }
  void setSpread(float value){
    spread = value*ringbufferL->getSize()/(TAPS*2);
  }
  void setAmount(float value){
    amount = value;
  }
  // void process(FloatArray input, FloatArray output){
  // }
  void process(AudioBuffer& input, AudioBuffer& output){
    filter->process(input, *buffer);
    FloatArray bufL = buffer->getSamples(LEFT_CHANNEL);
    FloatArray bufR = buffer->getSamples(RIGHT_CHANNEL);
    size_t len = input.getSize();
    ringbufferL->write(bufL.getData(), len);
    ringbufferR->write(bufR.getData(), len);
    float ph = spread*0.25;
    for(size_t i=0; i<TAPS; ++i){
      FloatArray bufL = buffer->getSamples(LEFT_CHANNEL+i*2);
      FloatArray bufR = buffer->getSamples(RIGHT_CHANNEL+i*2);
      float index = delay + ph*depth + spread*i*1.7;
      ringbufferL->delay(bufL.getData(), bufL.getSize(), delay_times[i*2], index);
      delay_times[i*2] = index;
      index = delay + ph*depth - spread*i*2.3;
      ringbufferR->delay(bufR.getData(), bufR.getSize(), delay_times[i*2+1], index);
      delay_times[i*2+1] = index;
    }
    buffer->multiply(amount/TAPS);
    output.copyFrom(input);
    output.multiply(1-amount); // scale dry signal
    FloatArray outL = output.getSamples(LEFT_CHANNEL);
    FloatArray outR = output.getSamples(RIGHT_CHANNEL);
    for(size_t i=0; i<TAPS; ++i){
      FloatArray bufL = buffer->getSamples(LEFT_CHANNEL+i*2);
      FloatArray bufR = buffer->getSamples(RIGHT_CHANNEL+i*2);
      outL.add(bufL);
      outR.add(bufR);
    }
  }
  static StereoChorusProcessor* create(float sr, size_t bs, size_t delaysize){
    AudioBuffer* buffer = AudioBuffer::create(2*TAPS, bs);
    CircularBufferType* ringbufferL = CircularBufferType::create(delaysize, bs);
    CircularBufferType* ringbufferR = CircularBufferType::create(delaysize, bs);
    MultiBiquadFilter* filter = MultiBiquadFilter::create(sr, 2, 1);
    filter->setLowPass(6000, FilterStage::BUTTERWORTH_Q);
    return new StereoChorusProcessor(buffer, ringbufferL, ringbufferR, filter);
  }
  static void destroy(StereoChorusProcessor* obj){
    AudioBuffer::destroy(obj->buffer);
    CircularBufferType::destroy(obj->ringbufferL);
    CircularBufferType::destroy(obj->ringbufferR);
    MultiBiquadFilter::destroy(obj->filter);
    delete obj;
  }
};

template<size_t TAPS=3>
class FilteredStereoChorusProcessor : public MultiSignalProcessor {
protected:
  StereoBiquadFilter* filter;
  StereoChorusProcessor<TAPS>* chorus;
public:
  FilteredStereoChorusProcessor(StereoBiquadFilter* filter,
				StereoChorusProcessor<TAPS>* chorus)
    : filter(filter), chorus(chorus) {}
  // FilteredStereoChorusProcessor(float sr, size_t bs, size_t delaysize){
  //   filter = StereoBiquadFilter::create(sr, 1);
  //   chorus = StereoChorusProcessor<TAPS>::create(sr, bs, 0.20*sr);
  //   // filter->setLowPass(8000, FilterStage::BUTTERWORTH_Q);
  //   filter->setHighPass(200, FilterStage::BUTTERWORTH_Q);
  // }
  // ~FilteredStereoChorusProcessor(){
  //   StereoBiquadFilter::destroy(filter);
  //   StereoChorusProcessor<TAPS>::destroy(chorus);
  // }
  void setDelay(float value){
    chorus->setDelay(value);
  }
  void setDepth(float value){
    chorus->setDepth(value);
  }
  void setSpread(float value){
    chorus->setSpread(value);
  }
  void setAmount(float value){
    chorus->setAmount(value);
  }
  void setHighPass(float fc){
    filter->setHighPass(fc, FilterStage::BUTTERWORTH_Q);
  }
  void setPhase(float phase){
    setDelay(phase*0.5+0.5);
  }
  void process(AudioBuffer& input, AudioBuffer& output){
    filter->process(input, output);
    chorus->process(output, output);
  }
  static FilteredStereoChorusProcessor* create(float sr, size_t bs, size_t delaysize){
    StereoBiquadFilter* filter = StereoBiquadFilter::create(sr, 1);
    StereoChorusProcessor<TAPS>* chorus = StereoChorusProcessor<TAPS>::create(sr, bs, delaysize);
    // filter->setLowPass(8000, FilterStage::BUTTERWORTH_Q);
    filter->setHighPass(200, FilterStage::BUTTERWORTH_Q);
    return new FilteredStereoChorusProcessor(filter, chorus);
  }
  static void destroy(FilteredStereoChorusProcessor* obj){
    StereoBiquadFilter::destroy(obj->filter);
    StereoChorusProcessor<TAPS>::destroy(obj->chorus);
    delete obj;
  }
  // static void destroy(FilteredStereoChorusProcessor* obj){
  //   delete obj;
  // }
};

template<class Processor>
class StereoSignalProcessor : public Processor {
protected:
  Processor right;
public:
  template <typename... Args>
  StereoSignalProcessor(Args&&... args) :
    Processor(std::forward<Args>(args)...), right(std::forward<Args>(args)...) {}
  void process(AudioBuffer& input, AudioBuffer& output){
    Processor::process(input.getSamples(LEFT_CHANNEL), output.getSamples(LEFT_CHANNEL));
    right.process(input.getSamples(RIGHT_CHANNEL), output.getSamples(RIGHT_CHANNEL));
  }
  template <typename... Args>
  static StereoSignalProcessor* create(Args&&... args){
    return new StereoSignalProcessor<Processor>(std::forward<Args>(args)...);
  }
  static void destroy(StereoSignalProcessor* processor){
    delete processor;
  }
};
#endif

template<size_t TAPS=3>
class StereoChorusProcessor : public MultiSignalProcessor {
protected:
  ChorusProcessor<TAPS>* left;
  ChorusProcessor<TAPS>* right;
public:
  StereoChorusProcessor(float sr, size_t bs, size_t ds){
    left = new ChorusProcessor<TAPS>(sr, bs, ds*1.1);
    right = new ChorusProcessor<TAPS>(sr, bs, ds*0.9);
  }
  void setDelay(float value){
    left->setDelay(value);
    right->setDelay(value);
  }
  void setDepth(float value){
    left->setDepth(value);
    right->setDepth(value);
  }
  void setSpread(float value){
    left->setSpread(value);
    right->setSpread(value);
  }
  void setAmount(float value){
    left->setAmount(value);
    right->setAmount(value);
  }
  void setPhase(float value){
    left->setPhase(value);
    right->setPhase(-value);
  }
  void setLowPass(float fc){
    left->setLowPass(fc);
    right->setLowPass(fc);
  }
  void setHighPass(float fc){
    left->setHighPass(fc);
    right->setHighPass(fc);
  }
  void process(AudioBuffer& input, AudioBuffer& output){
    left->process(input.getSamples(LEFT_CHANNEL), output.getSamples(LEFT_CHANNEL));
    right->process(input.getSamples(RIGHT_CHANNEL), output.getSamples(RIGHT_CHANNEL));
  }
  static StereoChorusProcessor<TAPS>* create(float sr, size_t bs, size_t delaysize){
    return new StereoChorusProcessor<TAPS>(sr, bs, delaysize);
  }
  static void destroy(StereoChorusProcessor<TAPS>* processor){
    delete processor;
  }
};

// class BufferingSignalProcessor : public SignalProcessor {
// protected:
//   CircularFloatBuffer* buffer;
//   SignalProcessor* processor;
//   size_t blocksize;
// public:
//   BufferingSignalProcessor(SignalProcessor* processor): processor(processor) {}
//   virtual float process(float input){
//     buffer->write(input);
//     if(buffer->getReadCapacity() >= blocksize){
//       // buffer size must be a multiple of blocksize
//       ASSERT(buffer->getContiguousReadCapacity() >= blocksize, "Misaligned buffer");
//       FloatArray data(buffer->getReadHead(), blocksize);
//       processor->process(data, data);
//       buffer->moveReadHead(blocksize);
//     }
//     return buffer->readAt(buffer->getWriteIndex() - blocksize);
//   }
//   virtual void process(FloatArray input, FloatArray output){
//     buffer->write(input);
//     if(buffer->getReadCapacity() >= blocksize){
//       // buffer size must be a multiple of blocksize
//       ASSERT(buffer->getContiguousReadCapacity() >= blocksize, "Misaligned buffer");
//       FloatArray data(buffer->getReadHead(), blocksize);
//       processor->process(data, data);
//       buffer->moveReadHead(blocksize);
//     }
//     return buffer->readAt(buffer->getWriteIndex() - blocksize);
//   }
// };

class StereoChorusPatch : public Patch {
private:
  // typedef FilteredStereoChorusProcessor<taps> StereoChorusMixProcessor;
  // typedef StereoSignalProcessor<ChorusProcessor<taps>> StereoChorusMixProcessor;
  typedef StereoChorusProcessor<taps> StereoChorusMixProcessor;
  // 
  StereoChorusMixProcessor* processor;
  AudioBuffer* outputbuffer;
  MorphingLFO* lfo;
public:
  StereoChorusPatch(){
    registerParameter(PARAMETER_A, "Rate");
    registerParameter(PARAMETER_B, "Depth");
    registerParameter(PARAMETER_C, "Spread");
    registerParameter(PARAMETER_D, "Mix");
    registerParameter(PARAMETER_AA, "LFO Shape");
    registerParameter(PARAMETER_AB, "Delay Time");
    processor = StereoChorusMixProcessor::create(getSampleRate(), getBlockSize(), 0.200*getSampleRate());
    processor->setSpread(0.2);
    lfo = MorphingLFO::create(getSampleRate(), TRIGGER_LIMIT, getBlockRate());
    lfo->setBeatsPerMinute(8);
    setParameterValue(PARAMETER_AA, (float)MorphingLFO::TRIANGLE/(MorphingLFO::NOF_SHAPES - 1));
    setParameterValue(PARAMETER_AB, 0.5f);
    setParameterValue(PARAMETER_AC, 0.5f);
    setParameterValue(PARAMETER_AD, 0.5f);
    outputbuffer = AudioBuffer::create(2, getBlockSize());
  }
  ~StereoChorusPatch(){
    StereoChorusMixProcessor::destroy(processor);
    MorphingLFO::destroy(lfo);
  }
  void buttonChanged(PatchButtonId bid, uint16_t value, uint16_t samples){
    switch(bid){
    case BUTTON_1:
      lfo->trigger(value, samples);
      if(value)
	lfo->reset();
    }
  }
  void processAudio(AudioBuffer &buffer) {
    float speed = getParameterValue(PARAMETER_A)*3-1;
    // speed += getParameterValue(PARAMETER_E);
    lfo->select(getParameterValue(PARAMETER_AA));
    lfo->clock(getBlockSize());
    lfo->adjustSpeed(speed);
    setButton(PUSHBUTTON, lfo->getPhase() < M_PI);
    processor->setDelay(getParameterValue(PARAMETER_AB));
    processor->setSpread(getParameterValue(PARAMETER_C));
    processor->setDepth(getParameterValue(PARAMETER_B));
    processor->setAmount(getParameterValue(PARAMETER_D));
    processor->setHighPass(getParameterValue(PARAMETER_AC));
    processor->setLowPass(getParameterValue(PARAMETER_AD));
    processor->setPhase(lfo->generate());
    processor->process(buffer, *outputbuffer);
    outputbuffer->getSamples(LEFT_CHANNEL).softclip();
    outputbuffer->getSamples(RIGHT_CHANNEL).softclip();
    buffer.copyFrom(*outputbuffer);
  }
};

#endif // __StereoChorusPatch_h__
